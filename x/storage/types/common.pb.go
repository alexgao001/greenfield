// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: greenfield/storage/common.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SourceType represents the source of resource creation, which can
// from Greenfield native or from a cross-chain transfer from BSC
type SourceType int32

const (
	SOURCE_TYPE_ORIGIN          SourceType = 0
	SOURCE_TYPE_BSC_CROSS_CHAIN SourceType = 1
	SOURCE_TYPE_MIRROR_PENDING  SourceType = 2
)

var SourceType_name = map[int32]string{
	0: "SOURCE_TYPE_ORIGIN",
	1: "SOURCE_TYPE_BSC_CROSS_CHAIN",
	2: "SOURCE_TYPE_MIRROR_PENDING",
}

var SourceType_value = map[string]int32{
	"SOURCE_TYPE_ORIGIN":          0,
	"SOURCE_TYPE_BSC_CROSS_CHAIN": 1,
	"SOURCE_TYPE_MIRROR_PENDING":  2,
}

func (x SourceType) String() string {
	return proto.EnumName(SourceType_name, int32(x))
}

func (SourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{0}
}

// BucketStatus represents the status of a bucket. After a user successfully
// sends a CreateBucket transaction onto the chain, the status is set to 'Created'.
// When a Discontinue Object transaction is received on chain, the status is set to 'Discontinued'.
type BucketStatus int32

const (
	BUCKET_STATUS_CREATED      BucketStatus = 0
	BUCKET_STATUS_DISCONTINUED BucketStatus = 1
	BUCKET_STATUS_MIGRATING    BucketStatus = 2
)

var BucketStatus_name = map[int32]string{
	0: "BUCKET_STATUS_CREATED",
	1: "BUCKET_STATUS_DISCONTINUED",
	2: "BUCKET_STATUS_MIGRATING",
}

var BucketStatus_value = map[string]int32{
	"BUCKET_STATUS_CREATED":      0,
	"BUCKET_STATUS_DISCONTINUED": 1,
	"BUCKET_STATUS_MIGRATING":    2,
}

func (x BucketStatus) String() string {
	return proto.EnumName(BucketStatus_name, int32(x))
}

func (BucketStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{1}
}

// RedundancyType represents the redundancy algorithm type for object data,
// which can be either multi-replica or erasure coding.
type RedundancyType int32

const (
	REDUNDANCY_EC_TYPE      RedundancyType = 0
	REDUNDANCY_REPLICA_TYPE RedundancyType = 1
)

var RedundancyType_name = map[int32]string{
	0: "REDUNDANCY_EC_TYPE",
	1: "REDUNDANCY_REPLICA_TYPE",
}

var RedundancyType_value = map[string]int32{
	"REDUNDANCY_EC_TYPE":      0,
	"REDUNDANCY_REPLICA_TYPE": 1,
}

func (x RedundancyType) String() string {
	return proto.EnumName(RedundancyType_name, int32(x))
}

func (RedundancyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{2}
}

// ObjectStatus represents the creation status of an object. After a user successfully
// sends a CreateObject transaction onto the chain, the status is set to 'Created'.
// After the Primary Service Provider successfully sends a Seal Object transaction onto
// the chain, the status is set to 'Sealed'. When a Discontinue Object transaction is
// received on chain, the status is set to 'Discontinued'.
type ObjectStatus int32

const (
	OBJECT_STATUS_CREATED      ObjectStatus = 0
	OBJECT_STATUS_SEALED       ObjectStatus = 1
	OBJECT_STATUS_DISCONTINUED ObjectStatus = 2
)

var ObjectStatus_name = map[int32]string{
	0: "OBJECT_STATUS_CREATED",
	1: "OBJECT_STATUS_SEALED",
	2: "OBJECT_STATUS_DISCONTINUED",
}

var ObjectStatus_value = map[string]int32{
	"OBJECT_STATUS_CREATED":      0,
	"OBJECT_STATUS_SEALED":       1,
	"OBJECT_STATUS_DISCONTINUED": 2,
}

func (x ObjectStatus) String() string {
	return proto.EnumName(ObjectStatus_name, int32(x))
}

func (ObjectStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{3}
}

// VisibilityType is the resources public status.
type VisibilityType int32

const (
	VISIBILITY_TYPE_UNSPECIFIED VisibilityType = 0
	VISIBILITY_TYPE_PUBLIC_READ VisibilityType = 1
	VISIBILITY_TYPE_PRIVATE     VisibilityType = 2
	// If the bucket Visibility is inherit, it's finally set to private. If the object Visibility is inherit, it's the same as bucket.
	VISIBILITY_TYPE_INHERIT VisibilityType = 3
)

var VisibilityType_name = map[int32]string{
	0: "VISIBILITY_TYPE_UNSPECIFIED",
	1: "VISIBILITY_TYPE_PUBLIC_READ",
	2: "VISIBILITY_TYPE_PRIVATE",
	3: "VISIBILITY_TYPE_INHERIT",
}

var VisibilityType_value = map[string]int32{
	"VISIBILITY_TYPE_UNSPECIFIED": 0,
	"VISIBILITY_TYPE_PUBLIC_READ": 1,
	"VISIBILITY_TYPE_PRIVATE":     2,
	"VISIBILITY_TYPE_INHERIT":     3,
}

func (x VisibilityType) String() string {
	return proto.EnumName(VisibilityType_name, int32(x))
}

func (VisibilityType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{4}
}

// SecondarySpSealObjectSignDoc used to generate seal signature of secondary SP
// If the secondary SP only signs the checksum to declare the object pieces are saved,
// it might be reused by the primary SP to fake it's declaration.
// Then the primary SP can challenge and slash the secondary SP.
// So the id of the object is needed to prevent this.
type SecondarySpSealObjectSignDoc struct {
	GlobalVirtualGroupId uint32 `protobuf:"varint,1,opt,name=global_virtual_group_id,json=globalVirtualGroupId,proto3" json:"global_virtual_group_id,omitempty"`
	ObjectId             Uint   `protobuf:"bytes,2,opt,name=object_id,json=objectId,proto3,customtype=Uint" json:"object_id"`
	// checksum is the sha256 hash of slice of integrity hash from secondary sps
	Checksum []byte `protobuf:"bytes,3,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *SecondarySpSealObjectSignDoc) Reset()         { *m = SecondarySpSealObjectSignDoc{} }
func (m *SecondarySpSealObjectSignDoc) String() string { return proto.CompactTextString(m) }
func (*SecondarySpSealObjectSignDoc) ProtoMessage()    {}
func (*SecondarySpSealObjectSignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_4eff6c0fa4aaf4c9, []int{0}
}
func (m *SecondarySpSealObjectSignDoc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecondarySpSealObjectSignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecondarySpSealObjectSignDoc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecondarySpSealObjectSignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecondarySpSealObjectSignDoc.Merge(m, src)
}
func (m *SecondarySpSealObjectSignDoc) XXX_Size() int {
	return m.Size()
}
func (m *SecondarySpSealObjectSignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_SecondarySpSealObjectSignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_SecondarySpSealObjectSignDoc proto.InternalMessageInfo

func (m *SecondarySpSealObjectSignDoc) GetGlobalVirtualGroupId() uint32 {
	if m != nil {
		return m.GlobalVirtualGroupId
	}
	return 0
}

func (m *SecondarySpSealObjectSignDoc) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func init() {
	proto.RegisterEnum("greenfield.storage.SourceType", SourceType_name, SourceType_value)
	proto.RegisterEnum("greenfield.storage.BucketStatus", BucketStatus_name, BucketStatus_value)
	proto.RegisterEnum("greenfield.storage.RedundancyType", RedundancyType_name, RedundancyType_value)
	proto.RegisterEnum("greenfield.storage.ObjectStatus", ObjectStatus_name, ObjectStatus_value)
	proto.RegisterEnum("greenfield.storage.VisibilityType", VisibilityType_name, VisibilityType_value)
	proto.RegisterType((*SecondarySpSealObjectSignDoc)(nil), "greenfield.storage.SecondarySpSealObjectSignDoc")
}

func init() { proto.RegisterFile("greenfield/storage/common.proto", fileDescriptor_4eff6c0fa4aaf4c9) }

var fileDescriptor_4eff6c0fa4aaf4c9 = []byte{
	// 583 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0x4d, 0x4f, 0xd4, 0x40,
	0x18, 0xc7, 0x5b, 0x20, 0x06, 0x46, 0x24, 0x4d, 0x83, 0x02, 0xbb, 0xa6, 0x4b, 0x3c, 0x11, 0x12,
	0xd8, 0x83, 0x31, 0xf1, 0xda, 0x4e, 0xc7, 0x65, 0x64, 0x69, 0x37, 0x33, 0xed, 0x26, 0x78, 0x99,
	0xf4, 0x65, 0x2c, 0x23, 0xdd, 0xce, 0xa6, 0x2f, 0xc6, 0xfd, 0x06, 0x1e, 0x8d, 0x5f, 0xc1, 0xa3,
	0x57, 0x3f, 0x04, 0x47, 0xe2, 0xc9, 0x78, 0x20, 0x06, 0xbe, 0x88, 0xd9, 0x76, 0xc1, 0xdd, 0xb8,
	0xb7, 0x3e, 0xcf, 0xef, 0x97, 0x67, 0xfe, 0x33, 0xcd, 0x03, 0x3a, 0x49, 0xce, 0x79, 0xf6, 0x5e,
	0xf0, 0x34, 0xee, 0x16, 0xa5, 0xcc, 0x83, 0x84, 0x77, 0x23, 0x39, 0x1a, 0xc9, 0xec, 0x78, 0x9c,
	0xcb, 0x52, 0xea, 0xfa, 0x3f, 0xe1, 0x78, 0x26, 0xb4, 0xf6, 0x22, 0x59, 0x8c, 0x64, 0xc1, 0x6a,
	0xa3, 0xdb, 0x14, 0x8d, 0xde, 0xda, 0x4e, 0x64, 0x22, 0x9b, 0xfe, 0xf4, 0xab, 0xe9, 0xbe, 0xf8,
	0xae, 0x82, 0xe7, 0x94, 0x47, 0x32, 0x8b, 0x83, 0x7c, 0x42, 0xc7, 0x94, 0x07, 0xa9, 0x1b, 0x7e,
	0xe0, 0x51, 0x49, 0x45, 0x92, 0xd9, 0x32, 0xd2, 0x5f, 0x81, 0x9d, 0x24, 0x95, 0x61, 0x90, 0xb2,
	0x8f, 0x22, 0x2f, 0xab, 0x20, 0x65, 0x49, 0x2e, 0xab, 0x31, 0x13, 0xf1, 0xae, 0xba, 0xaf, 0x1e,
	0x3c, 0x21, 0xdb, 0x0d, 0x1e, 0x36, 0xb4, 0x37, 0x85, 0x38, 0xd6, 0x5f, 0x83, 0x0d, 0x59, 0xcf,
	0x99, 0x8a, 0x2b, 0xfb, 0xea, 0xc1, 0x86, 0xd5, 0xbe, 0xba, 0xe9, 0x28, 0xbf, 0x6f, 0x3a, 0x6b,
	0xbe, 0xc8, 0xca, 0x9f, 0x3f, 0x8e, 0x1e, 0xcf, 0xe2, 0x4d, 0x4b, 0xb2, 0xde, 0xd8, 0x38, 0xd6,
	0x5b, 0x60, 0x3d, 0xba, 0xe0, 0xd1, 0x65, 0x51, 0x8d, 0x76, 0x57, 0xf7, 0xd5, 0x83, 0x4d, 0xf2,
	0x50, 0x1f, 0x5e, 0x02, 0x40, 0x65, 0x95, 0x47, 0xdc, 0x9b, 0x8c, 0xb9, 0xfe, 0x0c, 0xe8, 0xd4,
	0xf5, 0x09, 0x44, 0xcc, 0x3b, 0x1f, 0x20, 0xe6, 0x12, 0xdc, 0xc3, 0x8e, 0xa6, 0xe8, 0x1d, 0xd0,
	0x9e, 0xef, 0x5b, 0x14, 0x32, 0x48, 0x5c, 0x4a, 0x19, 0x3c, 0x31, 0xb1, 0xa3, 0xa9, 0xba, 0x01,
	0x5a, 0xf3, 0xc2, 0x19, 0x26, 0xc4, 0x25, 0x6c, 0x80, 0x1c, 0x1b, 0x3b, 0x3d, 0x6d, 0xa5, 0xb5,
	0xf6, 0xf9, 0x9b, 0xa1, 0x1c, 0xa6, 0x60, 0xd3, 0xaa, 0xa2, 0x4b, 0x5e, 0xd2, 0x32, 0x28, 0xab,
	0x42, 0xdf, 0x03, 0x4f, 0x2d, 0x1f, 0x9e, 0x22, 0x8f, 0x51, 0xcf, 0xf4, 0x7c, 0xca, 0x20, 0x41,
	0xa6, 0x87, 0x6c, 0x4d, 0x99, 0x0e, 0x5c, 0x44, 0x36, 0xa6, 0xd0, 0x75, 0x3c, 0xec, 0xf8, 0xc8,
	0xd6, 0x54, 0xbd, 0x0d, 0x76, 0x16, 0xf9, 0x19, 0xee, 0x11, 0xd3, 0x9b, 0x3f, 0xed, 0x14, 0x6c,
	0x11, 0x1e, 0x57, 0x59, 0x1c, 0x64, 0xd1, 0xe4, 0xfe, 0x7a, 0x04, 0xd9, 0xbe, 0x63, 0x9b, 0x0e,
	0x3c, 0x67, 0x08, 0xd6, 0x61, 0x35, 0x65, 0x3a, 0x6c, 0xae, 0x4f, 0xd0, 0xa0, 0x8f, 0xa1, 0xd9,
	0x40, 0x75, 0x36, 0x4c, 0x80, 0xcd, 0xd9, 0x5f, 0x7c, 0x88, 0xee, 0x5a, 0x6f, 0x11, 0x5c, 0x12,
	0x7d, 0x17, 0x6c, 0x2f, 0x22, 0x8a, 0xcc, 0x7e, 0x1d, 0xda, 0x00, 0xad, 0x45, 0xb2, 0x70, 0xa9,
	0xfb, 0xdc, 0x5f, 0x55, 0xb0, 0x35, 0x14, 0x85, 0x08, 0x45, 0x2a, 0xca, 0x26, 0x78, 0x07, 0xb4,
	0x87, 0x98, 0x62, 0x0b, 0xf7, 0xb1, 0x77, 0xde, 0x3c, 0xb1, 0xef, 0xd0, 0x01, 0x82, 0xf8, 0x0d,
	0xae, 0xcf, 0x5c, 0x22, 0x0c, 0x7c, 0xab, 0x8f, 0x21, 0x23, 0xc8, 0x9c, 0xbd, 0xd7, 0x7f, 0x02,
	0xc1, 0x43, 0xd3, 0x43, 0xda, 0xca, 0x32, 0x88, 0x9d, 0x13, 0x44, 0xb0, 0xa7, 0xad, 0x36, 0xa1,
	0x2c, 0x7c, 0x75, 0x6b, 0xa8, 0xd7, 0xb7, 0x86, 0xfa, 0xe7, 0xd6, 0x50, 0xbf, 0xdc, 0x19, 0xca,
	0xf5, 0x9d, 0xa1, 0xfc, 0xba, 0x33, 0x94, 0x77, 0xdd, 0x44, 0x94, 0x17, 0x55, 0x78, 0x1c, 0xc9,
	0x51, 0x37, 0xcc, 0xc2, 0xa3, 0xe8, 0x22, 0x10, 0x59, 0x77, 0x6e, 0xd5, 0x3e, 0x3d, 0x2c, 0x5b,
	0x39, 0x19, 0xf3, 0x22, 0x7c, 0x54, 0xef, 0xc9, 0xcb, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x92,
	0x0b, 0xd9, 0x78, 0x8f, 0x03, 0x00, 0x00,
}

func (m *SecondarySpSealObjectSignDoc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecondarySpSealObjectSignDoc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecondarySpSealObjectSignDoc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintCommon(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.ObjectId.Size()
		i -= size
		if _, err := m.ObjectId.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCommon(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.GlobalVirtualGroupId != 0 {
		i = encodeVarintCommon(dAtA, i, uint64(m.GlobalVirtualGroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCommon(dAtA []byte, offset int, v uint64) int {
	offset -= sovCommon(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecondarySpSealObjectSignDoc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalVirtualGroupId != 0 {
		n += 1 + sovCommon(uint64(m.GlobalVirtualGroupId))
	}
	l = m.ObjectId.Size()
	n += 1 + l + sovCommon(uint64(l))
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovCommon(uint64(l))
	}
	return n
}

func sovCommon(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommon(x uint64) (n int) {
	return sovCommon(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecondarySpSealObjectSignDoc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecondarySpSealObjectSignDoc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecondarySpSealObjectSignDoc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalVirtualGroupId", wireType)
			}
			m.GlobalVirtualGroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GlobalVirtualGroupId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommon
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommon
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommon(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCommon
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommon(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommon
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommon
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommon
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCommon
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCommon
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCommon        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommon          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCommon = fmt.Errorf("proto: unexpected end of group")
)
